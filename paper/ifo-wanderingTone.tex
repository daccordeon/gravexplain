\documentclass[paper-main.tex]{subfiles}


\begin{document}


 
% Tracking tones with the Viterbi algorithm
% explaination and successful application
% lean on the continuous gravitational waves angle
Continuous gravitational wave signals may wander slowly in frequency over time, due to stochastic internal processes in the superfluid interior of isolated neutron stars~\cite{MelatosDouglassSimula:2015,Jones:2010} or stochastic accretion flows in binary neutron stars~\cite{BildstenTB:1998}. 
%As also mentioned in Section~\ref{sec:introduction}, continuous wave searches often look for signals that wander slowly in frequency~\cite{ScoX1O2Viterbi:2019}. 
The audio analogue of this is a tone that wanders in frequency; a note that changes pitch. 
%Unlike the single tone described in Section~\ref{sec:single_tone}, finding the signal isnâ€™t as simple as searching for a peak in the spectrum for the full timeseries data.%observing run.


The analysis techniques used here are inspired by those used to search for continuous waves from spinning neutron in LIGO and Virgo data~\cite{SuvorovaEtAl:2016,SuvorovaEtAl:2017}.
Continuous wave searches are performed on long datasets (months to years in duration). 
The frequency of gravitational-wave emission wanders significantly over the observation period. 
In this context, ``significantly'' means ``across multiple frequency bins'', where the typical width of a frequency bin is the reciprocal of the total observing time~\cite{JKS:1998,ScoX1O2Viterbi:2019}

One method to search for a wandering signal is to split the data into several shorter segments which are analysed individually. 
The detection statistics in every segment are combined to form a grid in time and frequency (spectrogram). 
The value at each spectrogram point determines the likelihood that a signal is present at a particular time and frequency. 
In gravitational-wave data analysis, a detection statistic is used to calculate the likelihood of a signal given the antenna beam pattern of the detector, which varies with as the Earth rotates and orbits the Sun~\cite{JKS:1998}.
The detection statistic used depends on the type of target~\cite{JKS:1998,SuvorovaEtAl:2017}). 
In this work the detection statistic is the amplitude (modulus) of the Fourier transform of the data at each time segment, which maximizes the likelihood of detecting a sinusoid in Gaussian noise, as described in Appendix~\ref{app:sinusoid_likelihood}. 
The resulting spectrogram gives the Fourier amplitude for each frequency and time bin. 
The task is then to find the most likely wandering frequency signal through the spectrogram. 
The Viterbi algorithm~\cite{Viterbi:1967} is an efficient method to find the most likely path of a signal given an observation sequence. 
It is used in continuous wave searches for a range of astrophysical targets~\cite{ScoX1O2Viterbi:2019,ScoX1ViterbiO1:2017,MillhouseStrangMelatos:2020,PostMergerRemnantSearch:2019,SunEtAlSNR:2018,viterbi_application}. 
 
In Section~\ref{sec:viterbi} we review the Viterbi algorithm and its application to this work. 
In Section~\ref{sec:wanderingResults} we present the results for recovery of a wandering audio frequency. 

%The data from a gravitaitonal wave observation run can be many months to a year. 
%One method to search for a slowly wandering continuous wave signal is to split the data into several shorter intervals. 
%Each chunk is analysed seperately. 
%In our project we take a Fourier transform of each interval and then create a grid (or spectrogram) where each cell is the Fourier amplitude of a particular frequency at a particular time. 
%(In continuous wave searches, a detection statistic is used to calculate the likelihood of a signal being present in a particular frequency bin.)
%The task is then to find the best path through the spectrogram grid as if it where a weighted graph, where here the weights are the Fourier amplitudes. 
%The Viterbi algorithm~\cite{Viterbi:1967} is an efficient method find the best path through the grid. 
%It is used in contiuous wave searches for a range of astrophysical targets~\cite{ScoX1O2Viterbi:2019,ScoX1ViterbiO1:2017,MillhouseStrangMelatos:2020,PostMergerRemnantSearch:2019,SunEtAlSNR:2018,viterbi_application}. 




\subsection{The Viterbi algorithm}
\label{sec:viterbi}

\begin{figure}
\includegraphics[width=0.49\textwidth]{figures/viterbiDiagram.pdf}
\caption{\label{fig:viterbi}
A schematic diagram of the Viterbi algorithm. 
Each box represents an element in the time-frequency grid starting from the instant $t_0$ on the left and ending at $t_{N_t}$ on the right. 
Vertically, the grid starts from frequency $f_0$ at the bottom and ending at $f_{N_f}$ at the top. 
The colour of each circle indicates the likelihood that a signal is present in the box, where a lighter colour corresponds to higher likelihood. 
AT each time step, the paths can move up one $f$ step, move down one $f$ step, or stay at the same $f$ step (shown by lines in the diagram). 
Each circles has three paths leading to it indicated by the lines. 
The best path to each circle at each $t_i$ is highlighted in black. 
Some routes through the grid are found to be dead ends, such as the path ending at $t_1$ marked (a). 
At $t=t_{N_t}$ the algorithm chooses the terminating frequency circle which has the highest value given by equation~\ref{eqn:recursiveViterbi}, marked (b). 
The Viterbi path is the path leading to this circle, highlighted in orange from (b) to the start at (c). 
}
\end{figure}

%Here we overview the Viterbi algorithm and describe its usage in this work. 
%Thinking about this 
A spectrogram is a grid indexed by time $t$ and frequency $f$ where here there are $N_t$ and $N_f$ time and frequency bins respectively, as shown in Fig.~\ref{fig:viterbi}.
We label the elements of the grid as $t_i$ and $f_j$ with $i=0,1,2,...N_t$ and $j=0,1,2,...,N_f$. 
The value in each grid element is a detection statistic based on the time series data observed. 
It indicates the likelihood that a signal is present in the element. 
We label the normalised Fourier amplitude as $F(t_i,f_j)$. 
%In continuous wave searches the detection statistic depends on the type of gravitational wave source. 
%In this work we use the normalised Fourier amplitude, which we label $F(t_i,f_j)$. 


The objective is to find the most likely path through the grid given the data and any probabilistic constraints on how the frequency wanders from $t_i$ to $t_{i+1}$. 
In continuous wave searches, a physical model is used to decide how much the frequency of the signal is allowed to wander at each time step, which depends on the type of target. 
In this work, at each time step we allow the frequency to either a) stay in the same bin; b) move up a single frequency bin; or c) move down a single frequency bin. 
The probability of transitioning from $f_j$ at $t_i$ to any of $\{f_{j+1},f_j,f_{j-1}\}$ at $t_{i+1}$ is called the transition probability $A(f_k,f_m)$. 
In this work the three options have equal probability $A(f_k,f_m)=1/3$ for $k=m+1,m,m-1$ and $A(f_k,f_m)=0$ otherwise.


A path through the grid has a likelihood dependent on the detection statistic (the observation) and the transition probability.
If the starting probabilities are all equal, i.e. $Pr[f(t_0)] = 1/N_f$, the the probability of the frequency equalling $f(t_{i+1})$ at $t = t_{i+1}$ is defined recursively by
%If there is equal probability of starting $f_j$ at $t=t_0$, the probability of path $Q$ given the observation $O$ is 
\begin{eqnarray}
%P(Q|O) =& A(f_j) F(t=N_t,f_j), \nonumber \\ &~~ \times \dots, A(f_j) F (t=t_0,f_j).
Pr[f(t_{i+1})=f_j] =~& F[t_{i+1},f(t_{i+1})] \nonumber \\
                     &*A[f(t_{i+1}),f(t_i)]  \nonumber \\
                     & *Pr[f(t_i)].
\label{eqn:recursiveViterbi}
\end{eqnarray}
The sequence $f(t_0),f(t_1),\dots,f(t_{N_t})$ that maximizes $Pr[f(t_{N_t}) = f_j]$ is the optimal Viterbi path terminating in the frequency bin $f_j$. 
We can the maximize the latter quantity over $0 \leq j \leq N_f$ to find the optimal Viterbi path overall, i.e. terminating in any frequency bin. 


The Viterbi algorithm is an efficient method to find the Viterbi path. 
Here we describe the algorithm as pseudo-code referring to the schematic in Fig.~\ref{fig:viterbi}, where the circles indicate the elements of the spectrogram grid (lighter colours correspond to higher likelihood). 
The implementation used in this work is available online (see Appendix~\ref{app:code}).
\begin{enumerate}
\item Starting at $t_1$, each $f_j$ element has three possible paths it could originate from at $t_0$, indicated by the lines in Fig.~\ref{fig:viterbi}. 
At each $f_j$ element, the highest $F[t_0,f_j] A[f(t_0),f(t_1)]$ from the previous time step is selected, highlighted by the black lines in Fig.~\ref{fig:viterbi}. 
For example for the element labelled (a), the highest value is directly behind it, therefore the transition from $\{t_0,f_0\}$ to $\{t_1,f_0\}$ is selected. 
Each element has now selected the best path from the previous time step. 
In Fig.~\ref{fig:viterbi}, black lines show the best paths and grey lines show all other paths. 

\item Moving to $t_2$, the path with the highest value of the recursive relation in equation~\ref{eqn:recursiveViterbi} is selected for each $f_j$ as shown by the solid lines from $t_1$ to $t_2$ in Fig.~\ref{fig:viterbi}. 

\item Steps 2 is repeated until the end of the grid ($t=t_{N_t}$) is reached. 
Only the best paths are stored. 

\item At $t=t_{N_t}$, each $f_j$ has a value $Pr[f(t_{N_t})=f_j]$ (equation~\ref{eqn:recursiveViterbi}). 
The algorithm selects the terminating frequency $f(t_{N_t})$ with the highest value, marked (b) in Fig.~\ref{fig:viterbi}.

\item The Viterbi path is then found by backtracking along the best paths at each time step.
\jam{[Andrew mentioned providing a closed form here, which I'm not sure exists. The code works by storing three arrays: the weights, the score for the best path to a given vertex, and the index of the previous vertex along that path. Backtracking comprises of looping through that third array from the vertex in the last row with the highest score from the second array. I don't think we need to explain it any further than that.]}
In Fig.~\ref{fig:viterbi}, we see that the path ending at (b) started at (c). 
The Viterbi path is highlighted in orange in fig.~\ref{fig:viterbi}.
\end{enumerate}
The Viterbi algorithm is an example of a dynamical programming algorithm, where a computation can be broken down into a series of sub-computations.
The Viterbi path for a time series sequences spanning $t_0$ to $t_{N_t}$ contains the Viterbi path for sub-sequences of that time series. 
It is also very computationally efficient. \jam{[Justify this claim to efficiency? Cite something about it being $O(n^2)$ or whatever it is?]}

\begin{comment}
The route through the grid which maximises the overall probability 


Constraints are set on the allowable paths. 
In continuous wave searches, a physical model is used to decide how much the frequency can wander at each timestep, depends on the type of target. 
In this work we allow the frequency to either a) stay in the same bin; b) move up a single frequency bin; or c) move down a single frequency bin. 
We label the probability of transitioning from $f_j$ at $t_{i}$ to $f_{j+1,j,j-1}$ at $t_{i+1}$ as $A_{i,j}$. 
In this work the three transition option have equal probability. 


Our objective is now to find the most likely path through the grid given the data and transition constraints. 
This is the route which maximises the overall probability, which we call the `Viterbi path'.
In practice we sum the logarithm of the Fourier amplitude $\log O_{i,j}$ along the path.

 
The Viterbi algorithm begins at $t_{i=1}$. 
The algorithm selects the highest probability route for each $f_j$. 
\begin{equation}
A_{i,j} O_{i,j+1}
A_{i,j} O_{i,j}
A_{i,j} O_{i,j-1}
\end{equation}
At $t_{i=2}$ it then selects the best route to this point based on the accumulated probability along the paths so far. 
For example, at 


(a.) The grid point labelled (a) has $f_{j=3}$ and $t_{i=1}$. 
Looking back at the previous time, there are three options for where the path could have started from at $t_{i=0}$. These are $f_{j=4}$, $f_{j=3}$, or $f_{j=2}$. 
The algorithm selects $f_{j=3}$ as it has the highest value. 
(b.) The grid point labelled (b.) is not the best starting position for any of the cells at $t_{i=1}$, no paths starting from this position will be considered from now on. 





The probability of a path is given by the accumulated probability along the path. 
\begin{equation}

\end{equation}




The value of each element in the grid is the logarithm of the normalised Fourier amplitude, which we label $O_{i,j}$. 

Our objective is to find the most likely path through the grid which maximises the , the `best path'. 
In practice, we sum the logarithm of the Fourier amplitudes along the path. 

We label the time-frequency grid points as $t_i$ and $f_j$ respectively, where $i=1,2,...N_t$ and $j=1,2,...,N_f$ (and $N_t$ and $N_f$ are the total number of time and frequency bins respectively). 
Starting at $t_{i=2}$, the algorithm iterates calculates the best path to each $f_j$ from $t_{i=1}$ to $t_=2$.  through $t_i$, at each stage finding the best path to every $f_j$ from $t_{i=0}$. 



Abstractly speaking, the algorithm is given a weighted graph (e.g.\ the spectrogram grid), a sensible sequence of subgraphs (e.g.\ the columns of the spectrum at each time), and restrictions on connectivity (e.g.\ the allowed amount of frequency wander). 
At each iteration, the algorithm will find the best path to each node in the next sub-graph. 
This is repeated to the final sub-graph. 
%n, at each iteration, it will find the best path to each node in the next subgraph, all the way from the first subgraph. 
The Viterbi path is then the overall best path from the first sub-graph to the last. 
The overall best path from the first sub-graph to the last is then selected, which is called the Viterbi path. 
At the end, it selects the overall best path from the first to the last subgraph (here, from the start to end time), this overall best path is called the Viterbi path. 
See Appendix~\ref{app:viterbi} for the full details of the algorithm in this particular implementation.


% moved from above
The method requires a limit for the allowed frequency change over time, usually informed by a physical model. 
In this work the frequency $f$ path can move in one of three ways at each time bin: a) up one frequency bin; b) stay in the same frequency bin; or c) down one frequency bin. 
We set the frequency bin width to be $\Delta f = 0.3\,{\rm Hz}$ which corresponds to a maximum frequency wander of $0.11\,{\rm Hz}{\rm s}^{-1}$.
%In this work, the frequency wander limit is set to $0.11\,{\rm Hz} {\rm s}^{-1}$ which corresponds to one frequency bin per every time bin. 
In some cases, we see this proves poorly adjusted to the signal. 
\end{comment}

\subsection{Sample output}
\label{sec:wanderingResults}

To test the Viterbi algorithm, a signal with wandering frequency is played by the speaker and the output recorded via webcam as in Section~\ref{sec:single_tone}.
\jam{[The injected frequency wandered along a decaying sinusoid, it was not random.]}
%Note that when creating a wandering frequency signal, the phase change must be integrated up over time, as detailed in Appendix~\ref{app:phase_gotcha}.

\begin{figure*}
	\includegraphics[width=\textwidth]{figures/expt_overlay_2_viterbi_test_webcam.pdf}
	\caption{\label{fig:viterbi_overlay}
Recovery of a wandering tone. 
The spectrogram shows the observed frequency amplitude at each time-frequency step. 
The overlaid pink-dot and white-cross markers show the injected signal and recovered Viterbi path respectively. 
On the left, before $\sim 15\,{\rm s}$, the signal changes frequency too quickly for the Viterbi algorithm to recover. 
At $150\,{\rm s}$ the data appears anomalous, which may be due to some background noise. }
\end{figure*}


The results are shown in Fig.~\ref{fig:viterbi_overlay}, where the heatmap shows the spectrogram of the observed signal. 
The overlaid pink-dot and white-cross markers show the injected signal and recovered Viterbi path respectively maximized over all terminating frequency bins. 
The Viterbi path provides a good match to the injected frequency. 
%To the eye, the Viterbi algorithm easily recovers the injected frequency over time due to the high signal-to-noise ratio (SNR) of this experiment \han{What was the SNR? / can we quantify this?}.
Quantitatively, the Viterbi path is within one frequency bin ($\approx 0.3\,{\rm Hz}$) of the injected signal for $94\%$ of the time. 
\jam{[Andrew wanted something about ``percentage root mean-square-error'' along the path, can you explain what he wants me to calculate?]}

%The Viterbi path stays within one frequency bin (approximately $0.3\,{\rm Hz}$) of the injected tone for $94\%$ of the run. 
Initially the injected signal moves faster then the frequency wander limit, leading to the discrepancy observed for $t\lesssim 10\,{\rm s}$. 
%Note that the signal initially moves faster than the frequency wander limit, causing a discrepancy between the injected and recovered signals. 
%To fix this, the limit should be doubled, although this would then cause the recovered path to stray more often. 
There is also an anomaly at $150\,{\rm s}$, which illustrates what happens when the interferometer is disturbed, e.g. when someone walks nearby. 
The Viterbi algorithm is robust against such disturbances, recovering the optimal path promptly, as Fig.~\ref{fig:viterbi_overlay} shows. 
%is likely due to a disturbance around the interferometer (such as someone walking nearby).
%There also appears to be an anomaly at $150\,{\rm s}$, likely from a disturbance (such as someone walking) around the interferometer.

%Empirically, decreasing the signal-to-noise ratio closer to unity (by making the speaker quieter) causes the Viterbi algorithm to stray more from the signal. 
%However, since the only correlation through the grid is the signal, we always expect the Viterbi path to lie near to the signal no matter how high the noise is, and this is indeed what we see. \han{Should we show results for this?}


\end{document}
